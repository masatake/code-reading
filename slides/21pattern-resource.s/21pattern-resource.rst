-------------------------------------------------------------------------
コードパターン: データ型にひも付く関数群
-------------------------------------------------------------------------

.. include:: ../header.rst

概要
-------------------------------------------------------------------------
* 「ある型Tのデータに対して、それを活用するための関数群が定義されている」
  というパターンがある。
* この関数群の関係に着目して読み飛す。

データのライフサイクルに関連する関数の呼び出し順序
-------------------------------------------------------------------------
データのライフサイクル

.. figure:: ../../resource-lifecycle.svg
	:scale: 200%

関数群をデータのライフサイクルの観点で分類できることがある。

* 構築関数(初期化関数)
* 破壊関数(終末処理関数)
* その他(操作関数)


ライフサイクルと読み飛し(逆方向)
-------------------------------------------------------------------------
.. figure:: ../../resource-lifecycle.svg
	:scale: 200%

逆方向のデータフローの追跡(1)
  操作関数を呼び出し箇所に遭遇して、引数に与えらているデータの出自を知りたければ、
  構築関数を呼び出している箇所を探す。

逆方向のデータフローの追跡(2)
  破壊関数を呼び出し箇所に遭遇して、引数に与えらているデータがどのように活用されたか
  を知りたければ、構築関数を呼び出しているところまでの範囲で操作関数の呼び出しを探す。

ライフサイクルと読み飛し(順方向)
-------------------------------------------------------------------------
.. figure:: ../../resource-lifecycle.svg
	:scale: 200%

順方向のデータフローの追跡(1)
  操作関数を呼び出し箇所に遭遇して、引数に与えらているデータの寿命を知りたければ、
  破壊関数を呼び出している箇所を探す。

順方向のデータフローの追跡(2)
  構築関数を呼び出し箇所に遭遇して、引数に与えらているデータがどのように活用されるのか
  を知りたければ、破壊関数を呼び出しているところまでの範囲で操作関数の呼び出しを探す。

破壊関数が呼び出されたら、以降そのデータについて考えなくて良いはずである。

破壊関数の宣言、呼び出しがみつからない場合
-------------------------------------------------------------------------
* データのライフサイクル管理に参照計数(リファレンスカウント)を使っている。
* プログラム終了時にOSがデータ(リソース)を開放することを想定している。

例: FILE
-------------------------------------------------------------------------
コード
.........................................................................

.. code-block:: c

        struct t {
		FILE* fp;
		...
	} T;
	...
	T->fp = fopen("関心のあるファイル", "r");
	...
	fgets(buffer, size, T->fp);
	do_something(buffer);
	...
	fclose(T->fp);
	...


例: FILE
-------------------------------------------------------------------------
読み飛ばし
.........................................................................

.. figure:: ../../resource-lifecycle-FILE.svg
	:scale: 160%

* fopenが呼び出されていたら、どこかでFILE*の操作関数、例えば
  fprintfとかfgetsとった操作関数を探す。

* fopenで用意されたFILE*の寿命は、fcloseが呼び出されるまでである。

* fgetsの引数に渡しているFILE*の変数について出自を知りたければ、
  FILE*のデータの構築関数の一つfopenを呼び出している箇所を探
  す。

* fgetsの引数に渡しているFILE*の変数について寿命を知りたければ、
  FILE*のデータの破壊関数fcloseを探す。

関数群のみつけ方
-------------------------------------------------------------------------

* 同じヘッダファイル中で宣言されていることがある。
* 同じ.Cファイルの中で定義されていることがる。
* 関数の名前に共通のプレフィックスを持つことがある。
* manページのSEE ALSO(関連項目)の節に記載されていることがある。

----

デモ
  FILEの場合 /usr/include/stdio.hに宣言されていて、fが共通の
  プレフィックスとして使われている。

他の型の例(FILE)
-------------------------------------------------------------------------
構築関数

	* fopen
	* ...

操作関数

        * fgets
        * fread
        * fwrite
	* fprintf
        * fscanf
	* ...

破壊関数

	* fclose

他の型の例(DIR)
-------------------------------------------------------------------------
構築関数

	* opendir
	* ...

操作関数

	* readdir
	* ...
	
破壊関数

	* closedir

他の型の例(ソケット)
-------------------------------------------------------------------------
構築関数

	* socket
	* accept

操作関数(サーバ側)

	* bind
	* listen
	* accept

操作関数(クライアント側)

	* bind
	* connect

操作関数

	* read, recv
	* write, send

破壊処理

	* shutdown
	* close
	

その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
動的メモリ
.........................................................................

1. malloc(や内部でmallocを呼び出す関数)で確保して
2. freeで開放する。


その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
動的メモリの例
.........................................................................

.. code-block:: c

    static void
    file_name_free (struct file_name *p)
    {
      free (p->buf);
      free (p);
    }

    static struct file_name *
    file_name_init (void)
    {
      struct file_name *p = xmalloc (sizeof *p);

      /* Start with a buffer larger than PATH_MAX, but beware of systems
	 on which PATH_MAX is very large -- e.g., INT_MAX.  */
      p->n_alloc = MIN (2 * PATH_MAX, 32 * 1024);

      p->buf = xmalloc (p->n_alloc);
      p->start = p->buf + (p->n_alloc - 1);
      p->start[0] = '\0';
      return p;
    }

    /* 出典: coreutils/src/pwd.c */

その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
ロック
.........................................................................

1. pthread_mutex_lockあるいはpthread_mutex_trylockでロックして、
2. pthread_mutex_unlockでアンロックする。

その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
ロックの例
.........................................................................

.. code-block:: c

    /* Priority queue of merge nodes. */
    struct merge_node_queue
    {
      struct heap *priority_queue;  /* Priority queue of merge tree nodes. */
      pthread_mutex_t mutex;        /* Lock for queue operations. */
      pthread_cond_t cond;          /* Conditional wait for empty queue to populate
				       when popping. */
    };

    ...

    static void
    queue_insert (struct merge_node_queue *queue, struct merge_node *node)
    {
      pthread_mutex_lock (&queue->mutex);
      heap_insert (queue->priority_queue, node);
      node->queued = true;
      pthread_mutex_unlock (&queue->mutex);
      pthread_cond_signal (&queue->cond);
    }
    /* 出典: coreutils/src/sort.c */
		

その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
参照計数付きのデータ構造
.........................................................................

1. `ref`, `acquire`, `retain`, `get` といった名前のついた関数で参照を開始して、
2. `unref`, `release`, `put` といった名前のついた関数で参照を解除する。


その他の呼び出し順序のある関数群の例
-------------------------------------------------------------------------
参照計数付きのデータ構造の例
.........................................................................

try_module_getで参照数を増やしてmodule_putで参照数を減らす。

.. code-block:: c

    static int batadv_socket_open(struct inode *inode, struct file *file)
    {
	    unsigned int i;
	    struct batadv_socket_client *socket_client;

	    if (!try_module_get(THIS_MODULE))
		    return -EBUSY;

	    nonseekable_open(inode, file);

	    socket_client = kmalloc(sizeof(*socket_client), GFP_KERNEL);
	    if (!socket_client) {
		    module_put(THIS_MODULE);
		    return -ENOMEM;
	    }

      /* 出典 linux/net/batman-adv/icmp_socket.c */
