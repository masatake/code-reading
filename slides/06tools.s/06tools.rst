-------------------------------------------------------------------------
ツール
-------------------------------------------------------------------------

.. include:: ../header.rst

概要
-------------------------------------------------------------------------

コードリーディングに最低限必要と考えらえる3つのツールについて説明する。

 ソースコードファイルの閲覧
 	less
 	
 文字列検索
	grep
	
 ソースコードツリーの巡回
 	find, xargs

ソースコードファイルの閲覧
-----------------------------------------------------------------------
* 好きなエディタを使えば良い。
* 特に好みがなければ、とりあえずページャ(less)を使う。
* 付属マニュアルの閲覧にもページャを使うので操作を覚えておくと良い。

.. code-block:: console

	$ less [+行番号] FILE名

ソースコードファイルの閲覧
-----------------------------------------------------------------------
lessのキー操作
.......................................................................

	q
		終了
	SPACE(あるいは^F)
		次ページへ移動
	^B
		前ページへ移動
	\/
		文字列検索(前向き)

	?
		文字列検索(後ろ向き)

	n
		次の検索結果

	N
		前の検索結果

	*N* g
		ファイル中の *N* 行目へ移動

文字列検索
-----------------------------------------------------------------------
grepを使って、指定した文字列パターンをファイル群から探す。

.. code-block:: console

	$ grep [OPTIONS] -n [-e] PATTERN FILES...

* 正規表現メタ文字を含まない限り、PATTERNには検索文字列を指定する。
* シェルによる解釈を避けるためにシングルクォートでPATTERNをかこむ。
* ファイル名と、PATTERNがみつかった行番号、PATTERNがみつかった行そのものが表示される。
* 基本的なオプション

	-e 
		後にPATTERNが来ることを明示する。
	-n
		検索結果に行番号を含める。

文字列検索
-----------------------------------------------------------------------
grepの出力例
.......................................................................

.. code-block:: console

    $ grep -n -e '__init' audit.c audit_tree.c audit_watch.c auditfilter.c capability.c
    audit.c:937:static int __init audit_init(void)
    audit.c:968:__initcall(audit_init);
    audit.c:971:static int __init audit_enable(char *str)
    audit_tree.c:943:static int __init audit_tree_init(void)
    audit_tree.c:956:__initcall(audit_tree_init);
    audit_watch.c:520:static int __init audit_watch_init(void)
    auditfilter.c:157:int __init audit_register_class(int class, unsigned *list)
    capability.c:30:static int __init file_caps_disable(char *str)

文字列検索
-----------------------------------------------------------------------
ファイルの指定
.......................................................................

* 現在のディレクトリ中の 全ての.cファイルを対象に検索する

.. code-block:: console

	$ grep -e PATTERN *.c

* 現在のディレクトリ中の 全ての.cファイルおよびヘッダファイルを対象に検
  索する

.. code-block:: console

	$ grep -e PATTERN *.[ch]

* -rオプションをつけるとFILESにディレクトリが含まれている場合、そのディ
  レクトリ以下のファイルも全て検索の対象とする。

文字列検索
-----------------------------------------------------------------------
正規表現(の一部)
.......................................................................

正規表現メタ文字を使うと検索を詳細に制御できる。
メタ文字の一部を紹介する。

	^
		行頭にマッチする。
	\$
		行末にマッチする。
	\.
		任意の一文字にマッチする。
	[]
		括弧の間の一文字とマッチする。
	\?
		直前の表現に0回か1回マッチする。
	\*
		直前の表現に0回以上マッチする。
	\\+
		直前の表現に1回以上マッチする。
	\\b
		単語の端の空文字列にマッチする。
	\\t
		タブ文字にマッチする。

* \\を前置するとメタ文字の意味が無くなる。
* ``[ \t]``: スペースあるいは空白

文字列検索
-----------------------------------------------------------------------
grepのコマンドラインオプション
.......................................................................

-i
	大文字小文字を無視して検索する。
-v
	マッチしない行を表示する。
-B N
	マッチした前N行も表示する。
-A N
	マッチした後N行も表示する。
-l
	マッチした行を表示せずファイル名だけを表示する。
-L
	マッチしなかったファイル名だけを表示する。


文字列検索
-----------------------------------------------------------------------
姑息な例1: 文字列リテラル
.......................................................................

GUIアプリケーションのメニューバーにある File メニュー の定義箇所を探すために

.. code-block:: console

	$ grep -n -e File *.c

とすると ``FileDialog`` 、 ``TemporaryFile`` など 関係の無い名前にも
マッチしてしまう。

こういった場合、ダブルクォート(``"``)自体をパターンに含めてしまえば良い。

.. code-block:: console

	$ grep -n -e '"File"' *.c

あるいは

.. code-block:: console

	$ grep -n -e \"File\" *.c

とする。

文字列検索
-----------------------------------------------------------------------
姑息な例2: 書式付き出力
.......................................................................

痕跡文字列が書式付き出力経由で表示されていた場合、その痕跡文字列をそのまま
検索しても、何もみつからない。

次のような痕跡文字列を考える。
::

	3 errors are found.

これが実は、

.. code-block:: c

	printf("%d errors are found.\n", count);

というコードを経て出力されている場合、

.. code-block:: console

	$ grep -n -e '3 errors are found\.' *.c

としても検索にひっかからない。

書式付き出力で展開されていそうな箇所
には、 .\\+ を使って任意の文字列が適合するようパターンを調整
すれば良い。

.. code-block:: console

	$ grep -n -e '.\+ errors are found\.' *.c


文字列検索
-----------------------------------------------------------------------
姑息な例3: 関数定義
.......................................................................
* ソースコードを呼んでいると関数定義を探したくなることが良くある。
* 関数名で検索すると関数的だけでなくその関数の呼び出し箇所までマッチしてしまう。

.. code-block:: console

	$ grep -n -e 'foo' *.c
	a.c:7:	x = foo(3);
	a.c:20:  	y = foo(a);
	b.c:20	foo(int i)
	b.c:35:	if  (foo(a) < 0) {
	
関数定義にあたり関数名を行頭に書く、というインデントスタイルを採用している
ソフトウェアがある。

.. code-block:: c

    const char *
    foo(int i)
    {

このようなスタイルに従って記述されていると期待できる場合、 ^関数名 という
パターンで関数定義だけにマッチさせることができる。

.. code-block:: console

	grep -n -e ^foo *.c

文字列検索
-----------------------------------------------------------------------
姑息な例4: 構造体定義
.......................................................................
* 関数定義と同様に構造体定義を探そうと名前で検索するとその構造体型の変数定義
  もマッチしてしまう。

    .. code-block:: console

	$ grep -nH -e vector example.c 
	example.c:1:struct vector {
	example.c:6:struct vector
	example.c:7:vector_add(struct vector a, struct vector b)
	example.c:13:vector_innter_product(struct vector a, struct b)
	example.c:15:  struct vector tmp;
	...

* インデントスタイルに着目して定義だけを取り出す。

  - 構造体タグの後に改行無しでフィールドの定義を開始するスタイルの場合

     .. code-block:: console

	$ grep -nH -e 'vector \+{' example.c 
	example.c:1:struct vector {

  - パイプラインでgrepを2つ以上つないで絞り込んでも良い

      .. code-block:: console

  	$ grep -nH -e ''vector' example.c | grep '{'
	example.c:1:struct vector {

  - 構造体タグの後に、フィールドの定義を開始する前に改行を入れるスタイルの場合

    .. code-block:: console

	    $ grep -nH -e 'vector *$' example.c 


ソースコードツリーの巡回
-----------------------------------------------------------------------
findコマンド
.......................................................................

* 指定したディレクトリ以下にある指定した条件を満すファイルを列挙できる。
  

    .. code-block:: console

	    $ find DIR OPTIONS...
	
* 例: 現在のディレクトリ以下にある.cファイルとヘッダファイルを列挙する

    .. code-block:: console

	    $ find . -type f -name '*.[ch]'

* オプションで条件を指定する。

  -type 種類

  	f
		ファイルであれば条件を満す。
	d
		ディレクトリであれば条件を満す。

  -name PATTERN

  	名前がPATTERNと一致していたら条件を満す。
	シェルに解釈されないようにシングルクォートでかこむ。

	
ソースコードツリーの巡回
-----------------------------------------------------------------------
列挙したファイルへのコマンドの適用: find単体で
.......................................................................
* -execオプションで適用したいコマンドラインを指定する。

  - ``\``; でコマンドラインの末尾を表現する。
  - 適用時に {} の部分が列挙したファイルと置き換えられる。

* 現在のディレクトリ以下の.cファイルとヘッダファイルを列挙し、各ファイルを対象に 
  grep を実行する例

    .. code-block:: console

	    $ find . -type f -name '*.[ch]' -exec grep -nH -e PATTERN {} \;

ソースコードツリーの巡回
-----------------------------------------------------------------------
列挙したファイルへのコマンドの適用: xargsを併用して
.......................................................................

* xargs
 
 - 標準入力を読み込んであらたにコマンドラインを作成して、起動する。
 - 読み込んだ行(LINE)毎にコマンドラインを作成して、起動する。
 - xargsの引数でしたコマンドラインの断片にLINEを連結してコマンドラインを完成させて、
   起動する。

* 現在のディレクトリ以下の.cファイルとヘッダファイルを列挙し、各ファイルを対象に 
  grep を実行する例

    .. code-block:: console

	    $ find . type f -name '*.[ch]' | xargs grep -nH -e PATTERN
