C言語復習
=======================================================================

書籍でC言語を学習した人は多いでしょう。C言語について多くの書籍が市販されています。
しかし、それらは主にプログラムを書く、という視点で記述されています。
ここでは読む、という視点でC言語のいくつかの機能を見直してみます。

以降の説明で「痕跡文字列」という言葉を使います。その意味と位置付けの詳
細は :ref:`reading` にて説明します。コードリーディングを開始するソース
コード上の場所(「コードポイント」)をみつけるために使う最初の検索文字列、
と考えて下さい。


空白
-----------------------------------------------------------------------
区切り文字としてスペースやタブが使われますが、複数個連続していても、一つと
みなされます。凝った検索を行うときに考慮する必要があります。詳細は :ref:`tool`
にて説明します。

インデントスタイル
-----------------------------------------------------------------------
インデントスタイルはソフトウェアによって様々です。慣れないスタイルもあるかも
しれませんが、読む側の立場にあっては静かに受け入れる必要があります。どうしても
受け付けられないひどいスタイルに遭遇したら indent コマンドで再インデントして
も良いでしょう。

.. 例

筆者の経験ではたいていの場合1つのソフトウェアのなかではインデントスタイルは
統一されています。スタイルを把握しておけば、凝った検索を組み立てるときの
助けとなります。詳細は :ref:`tool`
にて説明します。

.. _literalstrs:

文字列定数の連結
-----------------------------------------------------------------------
ダブルクォートで囲まれた文字列を文字列リテラル、文字列定数あるいは固定文字列
と呼びます。空白で区切られた隣接する2つ以上の文字列はCコンパイラによって連結
され1つの文字列定数となります。

.. code-block:: c

	/* concat.c */
	const char* str = "abc" "def" "ghi";
	printf("=>%s\nb", str);

::

	$ gcc concat.c
	$ ./a.out
	=>abcdefghi

abcdefghiを痕跡文字列 とみたてて ソースコードツリー中でabcdefghiを
文字列検索しても、該当するコードポイントがみつかりません。

.. _cpp:

プリプロセッサ(cpp)
-----------------------------------------------------------------------
Cコンパイラは入力を処理する前にプリプロセッサを呼び出します。プリプロセッサ
にはプログラムを書く人にやさしく、読む人に厳しい側面があります。

プリプロセッサはインクルードファイルを読み込むこと、マクロを展開するこ
とでコンパイラへの入力を変形します。痕跡文字列がこの変形された入力に由
来している場合、変形前のソースコードツリーを検索してもみつかりません。

.. _runcpp:

プリプロセスだけの実行
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
gccの-Eオプションを使うと引数で与えたcファイルについてプリプロセスだけを実行して
結果を標準出力に表示できます。
::

    $ cat /tmp/foo.c
    #define x "abc"
    x

    $ gcc -E /tmp/foo.c
    # 1 "/tmp/foo.c"
    # 1 "<コマンドライン>"
    # 1 "/tmp/foo.c"

    "abc"


名前の合成
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

マクロ定義中で、 `'##'` が使われると、文字列を連結して、変数名、関数名、型名など識
別子を合成します。合成された名前はマクロ展開された結果に含まれます。

.. code-block:: c

    /* /tmp/foo.c */
    #define def_inc(A) \
      static int A;    \
      inc##A (void) { A++; }

    def_inc(x)  /* incx関数を定義される。*/
    def_inc(y)  

    int main(void)
    {
      incx();   /* ソースコードを呼んでいてincxやincy関数を発見して */
      incx();   /* その定義を探してみつからない。*/
      incy();
      return x + y;
    }

::

    $ gcc -E /tmp/foo.c
    ...省略
    static int x; incx (void) { x++; }
    static int y; incy (void) { y++; }

    int main(void)
    {
      incx();
      incx();
      incy();
      return x + y;
    }

    $ gcc /tmp/foo.c

    $ ./a.out 

    $ echo $?
    3


マクロによる文字列化
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

マクロ定義中で、 マクロ変数の前に `'#'` があるとマクロ変数の値が
(ダブルクォートで括られた)定数文字列へ展開されます。

.. code-block:: c

    #include <stdio.h>

    typedef enum pref_type {
      PREF_UINT,
      PREF_BOOL,
      PREF_ENUM,
      PREF_STRING,
      PREF_RANGE,
      PREF_STATIC_TEXT,
      PREF_UAT,
      PREF_OBSOLETE,
    } pref_type_t;

    /* Taken from
       http://anonsvn.wireshark.org/viewvc/trunk/ui/gtk/prefs_dlg.c?r1=46545&r2=46544&pathrev=46545 */

    static const char*
    get_pref_type_string(pref_type_t t)
    {
      switch (t)
	{
    #define CASE(T) case PREF_##T: return #T
	  CASE(UINT);
	  CASE(BOOL);
	  CASE(ENUM);
	  CASE(STRING);
	  CASE(RANGE);
	  CASE(STATIC_TEXT);
	  CASE(UAT);
	  CASE(OBSOLETE);
	default:
	  return "UNKNOWN";
	}
    }


    int
    main(int argc)
    {
      printf("=>%s\n", get_pref_type_string(argc));
      return 0;
    }

実行してみます
::

    $ gcc /tmp/bar.c
    gcc /tmp/bar.c
    $ ./a.out 
    ./a.out 
    =>BOOL
    $ ./a.out a
    ./a.out a
    =>ENUM
    $ ./a.out a b
    ./a.out a b
    =>STRING

``get_pref_type_string`` 関数だけを抜粋してマクロ展開してみると次の
ようになります。

.. code-block:: c

    static const char*
    get_pref_type_string(pref_type_t t)
    {
      switch (t)
	{

	  case PREF_UINT: return "UINT";
	  case PREF_BOOL: return "BOOL";
	  case PREF_ENUM: return "ENUM";
	  case PREF_STRING: return "STRING";
	  case PREF_RANGE: return "RANGE";
	  case PREF_STATIC_TEXT: return "STATIC_TEXT";
	  case PREF_UAT: return "UAT";
	  case PREF_OBSOLETE: return "OBSOLETE";
	default:
	  return "UNKNOWN";
	}
    }

goto文
-----------------------------------------------------------------------
通常「スパゲティコード化する」という理由でgoto文の使用はあまり、
推奨されていません。しかし現実には多くのソースコードで利用されています。

良く見るのは段階的に複数のリソースを確保して行くという処理において、途中で
失敗した場合のクリーンアップです。全てのリソースを確保できなかったので、
処理の続行をあきらめて、確保してしまったリソースを順次開放します。

.. code-block:: c

    static int __net_init netdev_init(struct net *net)
    {
	    INIT_LIST_HEAD(&net->dev_base_head);

	    net->dev_name_head = netdev_create_hash();
	    if (net->dev_name_head == NULL)
		    goto err_name;

	    net->dev_index_head = netdev_create_hash();
	    if (net->dev_index_head == NULL)
		    goto err_idx;

	    return 0;

    err_idx:
	    kfree(net->dev_name_head);
    err_name:
	    return -ENOMEM;
    }

  
    /* Taken from
       kernel-2.6.32-131.0.15.el6/linux-2.6.32-131.0.15.fc13.x86_64/net/core/dev.c */

三項演算子
-----------------------------------------------------------------------

三項演算子を使った式

.. code-block:: c

	D = A? B: C;

はAが真のときBを、偽(== 0)のときCを返すという意味になります。
if文を使って次のようにも書けます。

.. code-block:: c

	if (A)
		D = B;
	else
		D = C;

returnの値、if/whileなどの条件を記述する箇所で良く使われます。

ビット演算
-----------------------------------------------------------------------

ビット演算群を使って正数型(unsigned int)の変数を、フラッグ群として扱うことがあります。
またよりサイズの小さな正数を格納するのに使われることがあります。

フラッグ
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

フラッグ群として用いる場合、フラッグを操作すための定数(マスク値)を各フ
ラッグの種類毎に用意されているはずです。定数名をenumあるいは#defineを使っ
て用意して。定数値を `<<` 演算子で用意しています。

.. code-block:: c

	enum { 
		FLAG_X  = 1 << 0,        /* 0番目のビット */
		FLAG_Y  = 1 << 1,        /* 1番目のビット */
		...
		FLAG_Z  = 1 << n,        /* n番目のビット */
		FLAG_0N = FLAG_X|FLAG_Z, /* 0番目とn番目のビット */
        };

変数からフラッグのの値を取り出す箇所で、 `&` 演算子が使われます。

.. code-block:: c

	unsigned int var;
	...
	if (var & FLAG_X) {
		/* FLAG_Xで指定したビットが立っていれば、ここへ
		   制御がうつる。*/
		...
	}

	if (var & FLAG_0N) {
		/* FLAG_0Nで指定したいずれかのビットが立っていれば、
		   ここへ制御がうつる。*/
		...
	}

	if ((var & FLAG_0N) == FLAG_0N) {
		/* FLAG_0Nで指定した全てのビットが立っていれば、
		   ここへ制御がうつる。*/
		...
	}
	
変数中の特定のフラッグを立てるのに `|=` が使われます。

.. code-block:: c

	unsigned int var;
	...
	var |= FLAG_X;

逆に特定のフラッグを下げるのに `~` と `&=` が使われます。
`~` で 全ビットを反転した値を得ます。

.. code-block:: c

	unsigned int var;
	...
	var &= ~FLAG_X;

サイズの小さな正数
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
正数変数の中の特定にビット範囲を小さなサイズの正数を格納するのに使われ
ることがあります。例として4, 5, 6番目に3ビット長の正数が格納されている
ケースを想定します。

3ビット長の正数が何番目のビットから格納されているかを示すオフセット定数と、
3ビット長の正数部分を抜きとるためのマスク定数が定義されているでしょう。

.. code-block:: c
	
	#define SUBINT_OFFSET 4
	#define SUBINT_MASK (1<<SUBINT_OFFSET|1<<(SUBINT_OFFSET + 1)|1<<(SUBINT_OFFSET + 2))
	/* あるいは */
	#define SUBINT_RANGE 3
	#define SUBINT_MASK ((1 << (SUBINT_RANGE + 1)) - 1) << SUBINT_OFFSET
	
正数変数varから3ビット長の正数を取り出す処理は次のように記述されているかもしれません。

.. code-block:: c

	r = (var & SUBINT_MASK) >> SUBINT_OFFSET

`&` 演算子で3ビット長の正数が格納された箇所以外の全てのビット群をクリアした
値を生成します。この値をそのまま正数変数の値としてみると、格納した値よりも
16倍( 1 << 4 )大きいままです。 `>>`  演算子で調整します。

逆に値をセットする処理は次のように記述されているかもしれません。

.. code-block:: c

	var = (var & ~SUBINT_MASK) | (r << SUBINT_OFFSET);

`&` と `~` を使って 正数変数の 3ビット長の正数を格納する領域のビット群
をクリアします。一方、正数変数r中に3ビット長の正数の値が格納されていま
す。 `<<` 演算子で値の格納箇所をずらした値を作ります。最後に 格納箇所を
ずらした3ビット長の正数の値と、格納する領域だけをクリアした値とを `|`
演算子で 重ねあわせた値を作ります。

否定の否定
-----------------------------------------------------------------------

.. code-block:: c

	b = !!var 

と否定の演算子を2つ重ねた式が出てくることがあります。これは


	b = !(var == 0)

と同じ意味になります。
非0の値を1に、0をそのまま0に変換するのに使われます。

.. _scope:

スコープ
-----------------------------------------------------------------------

スコープとはある名前が参照されうる範囲のことです。ここでは型の名前について
扱いません。変数定義あるいは関数定義を指し示すものとしての名前を扱います。

詳細は :ref:`reading` にて説明しますが、ソースコードを読むこととは、制
御フローとデータフローを追跡する、という行為の繰り返しです。多くの場面
でそれは関数や変数を指し示す名前がどのように利用されているかを追跡する
ことになります。もし名前のスコープがわかれば、追跡しないといけない範囲
特定できます。

C言語には狭い順番に文内、.cファイル内、プログラム全域の3つのスコー
プがあります。以降では、各スコープについて説明します。ただし説明のために
順番を入れかえています。

文内
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

文中で定義された変数をローカル変数と呼びます。

.. code-block:: c

    int main(void)
    {
      for (int i = 0; i++; i < 10)
	  ;
      return i;
    }

このプログラムをコンパイルすると、 `return i` の箇所で文法エラーで失敗します。 
for文で定義された変数 `i` が定義されていますが、それはfor文の範囲からだけ
参照されうる名前です。for文の外にあるreturn文からは参照できません。リーディング
の立場から言うと、for文に定義されたiのデータフローを追う必要があっても、それは
for文の範囲だけに着目すれば十分、ということになります。

`{` と `}` を使うと複数の文をまとめた複文(ブロック)を作れます。ブロック内
で定義された変数はブロック内からしか参照できません。関数定義もブロックと
みなすことができます。関数の仮引数は関数定義のブロックをスコープとします。

.. code-block:: c

	int foo(int o)
	{
		int p;
		/* o, pが参照可能 */
		...
		{
			int q;
			/* o, p, qが参照可能 */
			...
		}
		/* o, pが参照可能 */
		...		
	}

規格化されたCの範囲では文中に関数を定義できないので、ローカル関数という
ものは存在しません。しかし文中で関数を宣言することはできます。

.. code-block:: c

	int foo(void)
	{
		extern int f(void);
		int g(void);
		
		return f() + g();
	}

プログラム全域をスコープに持つfとgについて、その存在を宣言することで
fooはその中でfとgを参照可能としています。このようなコードが出現する
ことはあまりありません。簡便な記述でソースコードツリーの様々な箇所で
参照できるようプログラム全域をスコープに持つ名前については、通常その
宣言をヘッダファイルに含めます。参照する側の.cファイルでは、そのヘッ
ダファイルをインクルードすることで、.cファイル内全体でその名前を参照
できます。

ブロック内で独自に宣言を記載して参照するのは理由ありと考えて良いでしょ
う。プログラム全域をスコープに持つ関数を定義しているが、それはソース
コードツリー中の極一部のソースコード中からだけ参照することを想定して
おり、他のソースコードから参照してしまうことが無いようにヘッダファイル
に宣言を記載していない、という場合です。

.. code-block:: c

   
    /*
     * Do not modify this file.
     *
     * It is created automatically by Makefile or Makefile.nmake.
     */

    #include "config.h"

    #include <gmodule.h>

    #include "moduleinfo.h"

    #ifndef ENABLE_STATIC
    G_MODULE_EXPORT const gchar version[] = VERSION;

    /* Start the functions we need for the plugin stuff */

    G_MODULE_EXPORT void
    plugin_register (void)
    {
      {extern void proto_register_wimaxmacphy (void); proto_register_wimaxmacphy ();}
    }

    G_MODULE_EXPORT void
    plugin_reg_handoff(void)
    {
      {extern void proto_reg_handoff_wimaxmacphy (void); proto_reg_handoff_wimaxmacphy ();}
    }
    #endif

    /* Taken from
       wireshark/plugins/wimaxmacphy/plugin.c */

プログラム全域
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

.. TODO: externの意味

ある.cファイル内にあって関数定義の外(トップレベルとも言う)でstatic修飾
子無しで定義されている関数あるいは変数の名前はプログラム全域から参
照できます。このようなスコープを持つ変数を特に大域変数と言います。ライ
ブラリを構成する.cファイル内でプログラム全域のスコープを持つ変数や関数
の名前をリンク先のプログラムでも、そのプログラム全域から参照可能です。

ただし参照する側で宣言が必要となります。関数についてはその定義部分が無け
れば、宣言とみなされます。変数についてはextern予約語がついていれば宣言
とみなされます。通常、宣言はヘッダファイルに記載されています。利用する
.cファイルで、そのヘッダファイルがインクルードされています。

.. 逆にある
.. .cファイルについて、どのようなヘッダファイルがインクルードされているか、
.. を調べれば、

リーディングにあたり、プログラム全域のスコープを持つ名前、特に変数名には
注意が必要です。データフローの追跡が格段に増します。

.cファイル内
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

ある.cファイル内にあって関数定義の外(トップレベルとも言う)でstatic修飾
子付きで定義されている関数あるいは変数の名前はその.cファイル内からだけ
参照されます。ファイルのトップレベルにあってstatic修飾子付きの変数や
関数をファイルローカル変数、あるいはファイルローカル関数と呼ぶことがあ
ります。もし同じ名前がソースコードツリー中の別のファイルで使われ
ていても、その実体(定義)は別です。

.. code-block:: c

	static int counter;
	static void func (void);


.. figure::  scope.svg

あるプログラムについて各.cファイルは、それぞれ役割があり、他の.c
ファイルに何らかの機能を提供しています。

ある.cファイルにはファイルローカルの変数や関数もあれば、static修飾子無
し(=プログラム全域スコープ)の関数もあるはずです。このうちプログラム全域
スコープを持つ関数が、その.cファイルで実現する機能を起動するための窓口
となります。ある.cファイルについてプログラム全体に対してどんな機能を提
供しているのか、という疑問が湧いたら、まずはそのファイルで定義されてい
るプログラム全域スコープの関数だけを調べれば良いでしょう。

ファイルローカルの関数や変数は、その窓口の下請けと位置付けることができ
ます。窓口が直接ファイルローカル変数にアクセスしないように、ファイルロー
カル変数へアクセスするためのファイルローカル関数群が用意されている場合
もあります。窓口となる関数はファイルローカル関数を経由してファイルロー
カル変数を利用しまう。

スコープとは関係ありませんが、staticとついた変数の値はプログラム起動時に
0に初期化されます。

.. 追跡しないといけなさそうなフローが複数ある場合、長い時間をかけて外れの
.. フローを読むのを避けるために、追跡量の少なさそうな箇所から始めたくなり
.. ます。.cファイルのスコープはフロー追跡の量を見積る重要なヒントとなりま
.. す。その名前について逆方向にフローを辿る場合、ソースコードツリー全域を
.. 検索する必要はありません。その.cファイル内での利用箇所だけを調べれば良
.. いでしょう。全てその.cファイル中のファイルローカル関数に行きつくはず
.. です。

.. .cファイルのインクルード

参照によるスコープの崩壊
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

ここまでで話が終れば良いのですが、残念ながらスコープの説明には続きがあります。
スコープとは名前に関するものでした。名前によって参照される定義は、ポインタ
変数を介して、名前に由来するスコープを越えて参照されてしまいます。

.. code-block:: c

	/* bar.h */
	void func(int * p);

.. code-block:: c

	/* bar.c */
	static int * pointer;

	void func(int * p)
	{
		pointer = p;		
	}

.. code-block:: c

        /* foo.c */
	#include "bar.h"
	static int file_private;

	...
	{
		...
		func(&file_private);
		...
	}


このコード例でfile_privateはfoo.c内でstatic修飾子付きで定義されています。
file_privateという名前の利用範囲については foo.c だけを調べれば良いという
ことになります。ところがfile_privateという名前で指す変数は、func関数に
アドレス参照演算子付きで渡したところで、bar.cから見えるようになります。
bar.cで定義された関数funcを経由してfile_privateという名前で指す変数の
アドレスがbar.cに知れてしまいます。bar.cではpointerポインタ変数経由
でその変数の値を参照、操作できてしまいます。

static修飾子付き変数については、名前ではなくアドレス経由で変数が
ファイルの外へ漏れてしまっていないか注意する必要があります。
static修飾子付き関数の参照を活用するケースについては、 :ref:`callback` に
て仔細に検討します。

コマンドライン引数
-----------------------------------------------------------------------

プログラムの起動引数はmain関数に渡されます。int型の第一引数がその個数を、
文字列(char*)の配列型の第二引数にその内容が渡されます。通常個数を示す変
数にargc、内容を格納する変数にargvの名前が付けられています。本当に適当
な痕跡文字列が見当らないとき、制御フローの追跡をmainから、データフロー
についてはこのargc, argvから開始することになります。

.. else while
.. gnu拡張
.. 引数と環境変数
.. シグネチャー、関数宣言
.. 仮引数の名前規則
.. コンパイルタイムとランタイム
.. 構造体フィールドの初期化
.. ネーミングコンベンション
.. 環境変数
